tasks.md を読み込み、未完了タスクを分析してバッチ実行計画を立てよ。

**注意:** Previous Responseがある場合は前回バッチの完了後の再計画である。
tasks.md のチェック状況を確認し、次のバッチを決定せよ。

**やること:**
1. 対象feature名を特定する
   - 初回（00-plan.md がない）: User Task から feature 名を抽出する
   - 再計画（00-plan.md がある）: 既存 00-plan.md の「## 対象feature」を優先する
   - 特定できない場合は「要件が不明確、情報不足」と判定する
2. `tasks_path = .kiro/specs/{feature}/tasks.md` を確定する
3. `{tasks_path}` を読み込む
   - ファイルが存在しない場合は「tasks.mdが存在しない、または空」と判定する
   - ファイルが空、またはタスク（`- [ ]` / `- [x]`）が1つもない場合も同様
4. 未完了タスク（`- [ ]`）を特定する
5. 全タスクが完了済み（`- [x]`）の場合、「全タスク完了」と判定する
6. 未完了タスクがある場合:
   a. 各タスクの実装スコープを見積もる（変更ファイル数・複雑さ）
   b. コードを調査し、影響範囲を特定する
   c. バッチを決定する:
      - 同じファイルを触るタスクは同一バッチに集約
      - 1バッチは関連ソースコードがコンテキストに収まる範囲に制限
      - (P)マーカー付きタスクでファイル競合がないものは並列バッチ候補
   d. バッチ種別を決定する:
      - 逐次バッチ: 依存関係があるタスク群、または(P)なしのタスク群
      - 並列バッチ: (P)マーカー付きで互いに独立した2つ以上のタスク群
7. 実装アプローチを決める
   - ナレッジ・ポリシーの制約に違反しないか照合する

**バッチ種別の判定:**
- 未完了に(P)タスクが2つ以上あり、互いにファイル競合がなく、各タスクがMedium以上のスコープ → 並列バッチ
- Smallスコープのタスクは並列化せず逐次バッチでまとめる（merge-batchの起動オーバーヘッドが並列化の効果を打ち消すため）
- それ以外 → 逐次バッチ
- 判断に迷う場合は逐次バッチを選択する（安全側に倒す）

**バッチサイズの判定基準:**
- Small（1-2ファイル変更）: 5-8タスクまで1バッチ
- Medium（3-5ファイル変更）: 2-3タスクまで1バッチ
- Large（6+ファイル変更）: 1タスクを1バッチ

**並列バッチのワーカー割当:**
- worker-1, worker-2 に均等に分配する
- 各ワーカーが触るファイルが重複しないことを確認する
- tasks.md 自体はワーカーの変更対象外（merge-batch で一括更新される）

**必須出力:**

```markdown
# バッチ実行計画

## 対象feature
- feature: {feature}
- tasks_path: `.kiro/specs/{feature}/tasks.md`

## 進捗
- 完了: {完了タスク数}/{全タスク数}
- 未着手: {未着手タスク数}

## バッチ種別
逐次 / 並列

## 今回のバッチ
| タスクID | タスク概要 | ワーカー割当 |
|----------|-----------|-------------|
| X.X | ... | - / worker-1 / worker-2 |

## 実装アプローチ
{バッチ内タスクの実装方針}

## 実装ガイドライン
- {Coderが従うべきガイドライン}
```
