## 導入

本機能は、`references/takt` に定義されているワークフロー領域のドメイン概念（Piece / Movement / Rule / Facet / 実行状態）を、ZAIN側へ移植するための要件を定義する。目的は、移植後のドメインモデルをTAKT互換の意味論で扱えるようにしつつ、型安全性を強化することである。

移植後のモデルは、ドメインプリミティブとAlways-Valid Domain Modelを前提とし、無効状態を構築時点で排除できなければならない。これにより、実行時バリデーション依存を減らし、要件単位でテスト可能な移植を実現する。

## 実装コンテキスト

- 既存実装の有無: あり（`zain.core.takt` ドメイン実装と対応テストを作成済み）
- 判定根拠:
  - `modules/core/src/main/scala/zain/core/takt/` に Piece/Movement/Facet/ExecutionState の公開型が存在する。
  - `.kiro/specs/references-takt-always-valid/` に要件・設計・タスク文書が作成済みである。
  - 参照元のドメイン定義は `references/takt/src/core/models/` に存在し、意味整合の基準として利用する。

## 要件

### 1. 移植対象ドメインの抽出範囲

**目的:** ドメイン設計者として、`references/takt` のどの概念を移植対象にしたかを一意に追跡し、移植漏れを防ぎたい。

**受け入れ条件:**
- 1.1 移植対象の分析を開始したとき、TAKT移植ドメイン定義は `references/takt/src/core/models/` の Piece設定、Movement設定、Rule、Output Contract、Part定義、実行状態を移植対象として列挙しなければならない。
- 1.2 移植対象を列挙したとき、TAKT移植ドメイン定義は各対象に対応する参照元ファイルパスを1件以上関連付けなければならない。
- 1.3 移植対象に含まれない型が検出された場合、TAKT移植ドメイン定義は除外理由を明示しなければならない。

**依存関係:** なし

### 2. ドメインプリミティブの構築制約

**目的:** ドメイン実装者として、識別子・名称・条件式・遷移先などの値をプリミティブ型のまま扱わず、取り違えと無効値混入を防ぎたい。

**受け入れ条件:**
- 2.1 外部入力からドメイン値を構築するとき、TAKT移植ドメインモデルは識別子・名称・条件式・遷移先をドメインプリミティブとして生成しなければならない。
- 2.2 文字列ベースのドメインプリミティブに空文字が与えられた場合、TAKT移植ドメインモデルはその値の生成を拒否しなければならない。
- 2.3 文字列ベースのドメインプリミティブに1文字の値が与えられたとき、TAKT移植ドメインモデルはその値の生成を許可しなければならない。
- 2.4 TAKT移植ドメインモデルは常に、生成済みドメインプリミティブを外部から破壊的に変更できない状態に保たなければならない。
- 2.5 `parseXxx` 系メソッドは常に `Either[Error, ParsedValue]` を返し、成功時は検証済みドメイン値を返さなければならない（`Either[Error, Unit]` を返してはならない）。

**依存関係:** 1

### 3. Piece集約のAlways-Valid制約

**目的:** ワークフロー利用者として、生成されたPieceが常に実行可能な初期整合性を持つことを保証したい。

**受け入れ条件:**
- 3.1 Pieceを生成するとき、TAKT移植ドメインモデルはMovementを1件以上含む場合のみ生成を許可しなければならない。
- 3.2 Movement一覧が0件の場合、TAKT移植ドメインモデルはPiece生成を拒否しなければならない。
- 3.3 initialMovementが省略されたとき、TAKT移植ドメインモデルは先頭Movementを初期Movementとして確定しなければならない。
- 3.4 initialMovementが指定され、その名前のMovementが存在しない場合、TAKT移植ドメインモデルはPiece生成を拒否しなければならない。
- 3.5 maxMovementsが省略されたとき、TAKT移植ドメインモデルは既定値10を設定しなければならない。
- 3.6 maxMovementsが0以下の場合、TAKT移植ドメインモデルはPiece生成を拒否しなければならない。
- 3.7 同一Piece内でMovement名が重複する場合、TAKT移植ドメインモデルはPiece生成を拒否しなければならない。
- 3.8 Rule遷移先が `COMPLETE` / `ABORT` 以外のMovement名を指す場合、そのMovement名が定義されていなければTAKT移植ドメインモデルはPiece生成を拒否しなければならない。

**依存関係:** 2

### 4. Movement構成とFacet参照のAlways-Valid制約

**目的:** ワークフロー設計者として、Movement定義の競合設定や参照不整合を構築時に排除したい。

**受け入れ条件:**
- 4.1 Movementを生成するとき、TAKT移植ドメインモデルは実行モードを `Sequential` / `Parallel` / `Arpeggio` / `TeamLeader` のいずれか単一値として保持しなければならない。
- 4.2 互換入力（`hasParallel` / `hasArpeggio` / `teamLeader`）を受け取る場合、2個以上が同時に有効ならTAKT移植ドメインモデルはMovement生成を拒否しなければならない。
- 4.3 Rule条件が空文字の場合、TAKT移植ドメインモデルはRule生成を拒否しなければならない。
- 4.4 top-level MovementのRuleに遷移先が未設定の場合、TAKT移植ドメインモデルはMovement生成を拒否しなければならない。
- 4.5 Facet参照を含むMovementを生成するとき、TAKT移植ドメインモデルは参照されたPersona・Policy・Knowledge・Instruction・Output Contractが定義済みである場合のみ生成を許可しなければならない。
- 4.6 Facet参照の整合性チェックは `parseXxx` として定義し、成功時は検証済みの参照モデル値を返さなければならない。
- 4.7 Facet参照の整合性チェックを行うとき、TAKT移植ドメインモデルは参照名だけでなくカテゴリ（Persona/Policy/Knowledge/Instruction/Output Contract）を保持したうえで照合しなければならない。

**依存関係:** 2, 3

### 5. 実行状態モデルのAlways-Valid制約

**目的:** 実行エンジン利用者として、Piece実行状態が不正遷移しないことを保証したい。

**受け入れ条件:**
- 5.1 Piece実行を開始したとき、TAKT移植ドメインモデルは実行状態を `running` として生成しなければならない。
- 5.2 Piece実行状態を生成したとき、TAKT移植ドメインモデルはiterationを0以上の値で保持しなければならない。
- 5.3 `COMPLETE` 遷移が適用されたとき、TAKT移植ドメインモデルは実行状態を `completed` に遷移させなければならない。
- 5.4 `ABORT` 遷移が適用されたとき、TAKT移植ドメインモデルは実行状態を `aborted` に遷移させなければならない。
- 5.5 未定義Movementへの遷移要求が発生した場合、TAKT移植ドメインモデルは実行状態の遷移を拒否しなければならない。

**依存関係:** 3, 4

### 6. 望ましくない入力に対する失敗契約

**目的:** 品質保証担当者として、無効入力時に部分的に壊れたドメインオブジェクトが生成されないことを検証したい。

**受け入れ条件:**
- 6.1 無効な外部入力が与えられた場合、TAKT移植ドメインモデルは失敗結果を返し、ドメインオブジェクトを生成してはならない。
- 6.2 無効入力による失敗が発生した場合、TAKT移植ドメインモデルは失敗原因を識別可能なエラー種別として返さなければならない。
- 6.3 同一の無効入力が再度与えられたとき、TAKT移植ドメインモデルは同一の失敗種別を返さなければならない。

**依存関係:** 2, 3, 4, 5

### 7. 検証可能性と不変性

**目的:** 開発チームとして、要件がテストで継続的に検証でき、移植後も不変性が維持されることを保証したい。

**受け入れ条件:**
- 7.1 テストを実行したとき、TAKT移植ドメインモデルは要件1から6の各受け入れ条件に対応するテストケースを1件以上提供しなければならない。
- 7.2 境界値テストを実行したとき、TAKT移植ドメインモデルは空文字、1文字、0件、1件、未定義参照のケースを網羅しなければならない。
- 7.3 TAKT移植ドメインモデルは常に、状態変更操作が既存インスタンスの破壊的更新ではなく新しいインスタンスを返す形で表現されなければならない。

**依存関係:** 1, 2, 3, 4, 5, 6

### 8. Rule意味論の拡張

**目的:** ワークフロー設計者として、`ai()/all()/any()` や対話専用フラグをRuleで表現し、実行時評価に直接利用したい。

**受け入れ条件:**
- 8.1 Rule条件はプレーン文字列だけでなく `ai("...")` と `all()/any()` を区別して保持しなければならない。
- 8.2 Ruleは `appendix` / `requiresUserInput` / `interactiveOnly` を保持しなければならない。
- 8.3 `all()/any()` は単一条件・複数条件の両方を表現できなければならない。

### 9. Output Contractドメイン

**目的:** 実装者として、Movementごとの出力契約をドメイン型で扱い、構築時に不正値を拒否したい。

**受け入れ条件:**
- 9.1 Movementは output contract item（`name`,`format`,`useJudge`,`order`）のコレクションを保持しなければならない。
- 9.2 output contract item コレクションはファーストクラスコレクションとして実装されなければならない。
- 9.3 item名・format・order(指定時) が不正な場合は `Either` で失敗しなければならない。

### 10. 実行時コンテキスト拡張

**目的:** 実行エンジン利用者として、遷移判定に必要な出力履歴・入力履歴・セッション情報を不変状態で保持したい。

**受け入れ条件:**
- 10.1 `PieceExecutionState` は `movementOutputs` / `lastOutput` / `userInputs` / `personaSessions` / `movementIterations` を保持しなければならない。
- 10.2 状態更新APIは常に新インスタンスを返さなければならない。

### 11. RuleEvaluator実行順

**目的:** 実行器実装者として、参照実装と同等の優先順でRuleを評価したい。

**受け入れ条件:**
- 11.1 評価順は `aggregate -> phase3 tag -> phase1 tag -> ai judge -> ai judge fallback` でなければならない。
- 11.2 評価結果は「一致したrule index + 一致手法」を返さなければならない。
- 11.3 例外で制御してはならず、失敗は `Either` で表現しなければならない。

### 12. 実行モード構成情報

**目的:** ワークフロー設計者として、Parallel/Arpeggio/TeamLeader の設定をドメイン型で保持し、実行モードとの不整合を防ぎたい。

**受け入れ条件:**
- 12.1 Parallel/Arpeggio/TeamLeader の各構成情報は独立したドメイン型で定義されなければならない。
- 12.2 `MovementExecutionMode` と構成情報が矛盾する場合はMovement生成を拒否しなければならない。

### 13. ループ監視設定

**目的:** 実行器実装者として、loop detection / loop monitor の設定を型で表現し、未定義movement参照を構築時に排除したい。

**受け入れ条件:**
- 13.1 loop detection 設定（最大連続回数・action）をドメイン型として保持しなければならない。
- 13.2 loop monitor 設定（cycle/threshold/judge rules）をドメイン型として保持しなければならない。
- 13.3 cycle/judge遷移が未定義movementを参照する場合はPiece生成を拒否しなければならない。
